%%

import re

from nodes import *

try:
    u = unicode
except Exception as e:
    u = str

_is = [] # _is is short for "Indent Stack"
def checkindent(indent, start):
    sindent = len(start) - start.rfind('\n') - 1
    ci = len(_is) # Current indent index

    if indent == ci:
        # We're looking at a new indentation, to potentially push it
        # on the stack if we can.

        if ci == 0 or sindent > _is[-1]:
            _is.append(sindent)
            return True

        # It is not higher, so we just tell the parser that we
        # can't continue on that indentation level.
        return False

    if indent == ci - 1:
        # We're in the current block and want to check if this
        # line is correctly indented.

        # We're at the correct level, so we just return True
        if sindent >= _is[-1]: return True

        # We're looking at a deindent, so we pop the current indent
        # level from the stack.
        _is.pop()
        return False


%%

comment = /\s*#\s.*/m
_space = /[ \t]*/
fullspace = /([ \t]*\n)*[ \t]*/
EOL = "\n"

ident = /[-$\w:]+/u
vident = /[a-zA-Z_][a-zA-Z0-9_]*/

access_or_funcall = b:[ Balanced("[", "]", "\\") | Balanced("(", ")", "\\") ] -> b
variable_component = i:vident a:access_or_funcall* -> i + "".join(a)
variable_dotted = i:OneOrMoreSeparated(variable_component, ".") -> u(".").join(i)
variable = "$" i:OneOrMoreSeparated(variable_dotted, "|") -> u("{{{{ {0} }}}}").format(u("|").join(i))

delimited_line(delim) = delim l:line(delim)? delim -> l or ""

string = delimited_line("\"") | delimited_line("'")

tag = "@" !"/" i:ident -> NodeTag(i)

id = '#' i:[variable | ident] -> NodeId(i)
    # <div id="zoum">

cls = "." i:[variable | ident] -> NodeClass(i)

attrib = key:ident "=" value:[ string | line(/\s/) ] -> NodeNamed(key, value)

single_prop = "\\" i:[variable | ident] -> NodeSingle(i)

attribute = _space? a:[id | cls | single_prop | attrib] -> a

lineelt(terminator) =
       "@/" i:ident a:attribute* -> NodeTag(i).set_selfclosing().set_attributes(a)

    |  t:tag _space? a:attribute* _space? "[" i:line("]")? "]" ->
        t.set_attributes(a).set_line(i or "")

    | t:tag _space? a:attribute* _space? i:line(terminator)? ->
        t.set_attributes(a).set_line(i)

    | variable

    | \\ t:/./ -> t
        # Backslashed terminator.
    | !terminator c:/./ -> c

line(terminator=EOL) = e:lineelt(terminator)+ -> NodeLine(e)

blockstart(indent) =
      t:tag _space? a:attribute* _space? i:line? EOL b:block(indent + 1) ->
        return t.set_attributes(a).set_block(b).set_line(i)

    | a:attribute+ i:line? EOL b:block(indent + 1)? ->
        NodeTag("div").set_attributes(a).set_block(b).set_line(i)

    | "%" _space? j:ident c:/[^\n]*/ EOL b:block(indent + 1)? -> NodeJinja(j, c, b)

    | c:line _space? EOL? ->
        return c

    | s:_space? e:EOL? -> s + e

block(indent) =
    lines:[
        start:fullspace { checkindent(indent, start) } block:blockstart(indent) -> [start, block]
    ]+ ->
        return NodeBlock(lines)
